#include <iostream>
#define MAXWORDLENGTH  10

//-------------------------- BK Tree -----------------------------------//

struct Tnode {
    char* word[MAXWORDLENGTH];
    int next[2 * MAXWORDLENGTH];

    Tnode(char str[]) {
        *word = str;

        for (int i = 0; i < 2; i++)
            next[i] = 0;
    }

    Tnode() {}
};


//--------------------------- Structures  -----------------------------//

struct entry
{
    char* word[MAXWORDLENGTH];
    //payload//

    entry(char str[]) {
        *word = str;

        //payload//
    }

    entry() {}
};

struct entry_list   
{
    entry entryx;
    entry* next;

    entry_list(entry x) {
        entryx = x;
        next = NULL;
    }

    entry_list() {}
};


struct Index        
{
    entry entryx;
    entry_list list;

    Index(entry x) {
        entryx = x;
        list = entry_list();
    }

    Index() {}
};


//--------------------------- Keyword Matching -----------------------------//

bool exact_matching(char str1[], char str2[]) 
{
    int i = 0;
    while (str1[i] != NULL && str2[i] != NULL) {
        if (str1[i] == str2[i])
            i++;
        else
            return false;
    }
    if (str1[i] == NULL && str2[i] == NULL)
        return true;
    else
        return false;
}


int hamming_distance(char str1[], char str2[])
{
    int counter = 0;
    int i = 0;
    while (str1[i] != NULL && str2[i] != NULL) {
        if (str1[i] == str2[i])
            i++;
        else {
            counter++;
            i++;
        }
    }
    return counter;
}

int levenshtein_distance(char str1[], char str2[], int m, int n)
{
    if (m == 0)
        return n;

    if (n == 0)
        return m;

    if (str1[m - 1] == str2[n - 1])
        return levenshtein_distance(str1, str2, m-1, n-1);
    
    return 1;
}

//---------------------------------------------------------------------------------//

int main()
{
  return 0;
}
